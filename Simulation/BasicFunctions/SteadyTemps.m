function [T,HTcond,HTconv,HTrad]= SteadyTemps(block,Inlet)
%Solve problem of form xdot = Ax-b for xdot =0.
%final solution is x = A\b;
%states represent  heat transfer into each node/layer, the temperatures of each node/layers, and inlet Flow2 and Flow1 temperatures, Qerror term associated with the small error in air flow rate so that the deltaT and Tavg constraints can both be satisfied
%like the heat exchanger this averages the inlet and exit temperature for the gas streams, and assumes the solid temperature states correspond to the average for the node
global F
a = .5; %weighting of previous node temperature on convection HT calculation
nodes = block.nodes;
if isfield(block,'Cells')
    C = block.Cells;
else C = 1;
end
if ~isfield(block,'columns')
    columns = block.nodes;
    rows = 1;
else 
    columns = block.columns;
    rows = block.rows;
end
q1 = SpecHeat(Inlet.Flow1).*NetFlow(Inlet.Flow1)/(C*rows);
s = 2; %at minimum a flow and a solid mass (reformer)
inT = 1;
if isfield(Inlet,'Flow2')
    if strcmp(block.direction ,'crossflow')
        q2 = SpecHeat(Inlet.Flow2).*NetFlow(Inlet.Flow2)/(C*columns);
    else
        q2 = SpecHeat(Inlet.Flow2).*NetFlow(Inlet.Flow2)/(C*rows);
    end
    s = 3; %at minimum 2 flows & a solid mass
    inT = 2;
end
if isfield(block,'FCtype') %fuel cell or electrolyzer
    [h,h_s] = enthalpy(block.T.Elec,{'H2','H2O','O2','CO','CO2','CH4'});
    h_rxn1 = h.CO+3*h.H2-h.CH4-h.H2O;
    h_rxn2 = h.CO2+h.H2-h.CO-h.H2O;
    h_rxn3 = h.H2+.5*h.O2-h.H2O;
    Q.gen = (block.Current/(2*F).*h_rxn3-block.Current*block.Voltage)/1000;%kW of heat generated by electrochemistry (per node & per cell)
    Q.direct = h_rxn1.*block.R_CH4+h_rxn2.*block.R_WGS; %kW of cooling per cell;
    switch block.Reformer
        case 'internal'
            Q.indirect = h_rxn1.*block.R_CH4ref+h_rxn2.*block.R_WGSref; %kW of cooling per cell
            s=6; %3 flows and 3 solids
            Cells2Flow3=1; % set equal to 1 to model the cell next to the Flow3
            C8 = (block.h_flow3*block.A_Node)/Cells2Flow3/1000;
            q3 = q1;
        case {'adiabatic';'direct';'external';'none'}%  no direct heat transfer
            s=5; %2 flows and 3 solids
    end
    %ion transport across membrane (sensible enthalpy
    switch block.FCtype
        case {'SOFC';'SOEC';'rSOFC'}
            Q.ion = block.Current/(4*F*1000).*h_s.O2; %O2 ion crossing over (kW)
        case {'MCFC';'MCEC';'rMCFC'}
            Q.ion = block.Current/(4*F*1000).*h_s.O2 + block.Current/(2*F*1000).*h_s.CO2;% O2 & CO2 ion crossing over
    end
    c = length(block.Flow2Dir(1,:)); %extra constraint for average electrolyte temperature and column inlet to outlet
else
    Q = [];
    c = 0;
end
states = 2*s*nodes+inT;

%% heat input/mass transfer terms
b = zeros(states+c,1);
if ~isempty(Q)
    for k = 1:1:nodes
        b(k+(s+1)*nodes) = Q.ion(k);
        b(k+(s+2)*nodes) = (-Q.gen(k)+ Q.direct(k));
        b(k+(s+3)*nodes) = -Q.ion(k);
        if s ==6
            b(k+(s+5)*nodes) = Q.indirect(k);
        end
    end
end
if isfield(block,'Qref')
    for k = 1:1:nodes
        b(k+s*nodes) = block.Qref(k);
    end
end
%% Convection transfer between flows and solids
A = zeros(states+c,states);
if s <=3
    hA = block.Convection;
    for k = 1:1:nodes
        %% averaging inlet and outlet temp for gaseous nodes
        %QT1 : heat transfer into primary flow
        A(k,k) = -1;
        A(k,k+(s+1)*nodes) = hA;
        A(k,k+s*nodes) = -(1-a)*hA;
        [i,j] = find(block.Flow1Dir==k);
        if j==1 %first column averaged with inlet temperature
            A(k,2*s*nodes+1) = -a*hA;
        else % other columns averaged with previous one
            k2 = block.Flow1Dir(i,j-1);
            A(k,k2+s*nodes) = -a*hA;
        end

        %QT2 : heat transfer into solid
        A(k+nodes,k+nodes) = -1;
        if s==2
            A(k+nodes,k+(s+1)*nodes) = -1*hA;
            A(k+nodes,k+s*nodes) = (1-a)*hA;
            if j==1 %first column averaged with inlet temperature
                A(k+nodes,2*s*nodes+1) = a*hA;
            else % other columns averaged with previous one
                A(k+nodes,k2+s*nodes) = a*hA;
            end
        elseif s==3
            A(k+nodes,k+(s+1)*nodes) = -2*hA;
            A(k+nodes,k+s*nodes) = (1-a)*hA;
            A(k+nodes,k+(s+2)*nodes) = (1-a)*hA;
            if j==1 %first column averaged with inlet temperature
                A(k+nodes,2*s*nodes+1) = a*hA;
            else % other columns averaged with previous one
                A(k+nodes,k2+s*nodes) = a*hA;
            end
            [i,j] = find(block.Flow2Dir==k);
            if j==1 %first column averaged with inlet temperature
                A(k+nodes,2*s*nodes+2) = a*hA;
            else
                k2 = block.Flow2Dir(i,j-1);
                A(k+nodes,k2+(s+2)*nodes) = a*hA;
            end

            %QT3 : heat transfer into hot flow
            A(k+2*nodes,k+2*nodes) = -1;
            A(k+2*nodes,k+(s+1)*nodes) = hA;
            A(k+2*nodes,k+(s+2)*nodes) = -(1-a)*hA;
            if j==1 %first column averaged with inlet temperature
                A(k+2*nodes,2*s*nodes+2) = -a*hA;
            else % other columns averaged with previous one
                A(k+2*nodes,k2+(s+2)*nodes) = -a*hA;
            end
        end

        %Tcold: Temperature of cold flow
        A(k+s*nodes,k) = 1;
        A(k+s*nodes,k+s*nodes) = -q1;
        [i,j] = find(block.Flow1Dir==k);
        if j==1 %first column receives fresh air
            A(k+s*nodes,2*s*nodes+1) = q1;
        else
            index = block.Flow1Dir(i,j-1);
            A(k+s*nodes,index +s*nodes) = q1;
        end

        %Tsolid: Temperature of solid
        A(k+(s+1)*nodes,k+nodes) = 1;
        if s==3
            %Temperature of secondary flow
            A(k+(s+2)*nodes,k+2*nodes) = 1;
            A(k+(s+2)*nodes,k+(s+2)*nodes) = -q2; 
            [i,j] = find(block.Flow2Dir==k);
            if j==1 %first column receives fresh flow
                A(k+(s+2)*nodes,2*s*nodes+2) = q2; %fresh inlet
            else
                index = block.Flow2Dir(i,j-1);
                A(k+(s+2)*nodes,index + (s+2)*nodes) = q2;
            end
        end
    end
    % remove gaseous temperature averaging from 1st node
    k1 = block.Flow1Dir(:,1); %first column
    for j =1:1:length(k1)
        k = k1(j);
        A(k,k+s*nodes) = A(k,k+s*nodes) -a*hA; %HT to cold flow from solid
        A(k,2*s*nodes+1) = A(k,2*s*nodes+1) +a*hA; %ignore cold flow inlet

        A(k+nodes,k+s*nodes) = A(k+nodes,k+s*nodes) +a*hA;%HT to solid from cold flow
        A(k+nodes,2*s*nodes+1) = A(k+nodes,2*s*nodes+1) -a*hA;%ignore cold flow inlet
    end
    if s==3
        k1 = block.Flow2Dir(:,1); %first column
        for j =1:1:length(k1)
            k = k1(j);
            A(k+2*nodes,k+(s+2)*nodes) = A(k+2*nodes,k+(s+2)*nodes) - a*hA; %HT to hot flow from solid
            A(k+2*nodes,2*s*nodes+2) = A(k+2*nodes,2*s*nodes+2) + a*hA; %ignore hot flow inlet

            A(k+nodes,k+(s+2)*nodes) = A(k+nodes,k+(s+2)*nodes) + a*hA;%HT to solid from hot flow
            A(k+nodes,2*s*nodes+2) = A(k+nodes,2*s*nodes+2) - a*hA;%ignore hot flow inlet
        end
    end
else
    %all heat transfer coefficients converted to kW/K: thus Q = C*(T1-T2) is in kW
    C1 = (block.k_plate2*block.L_node*block.W_node/block.t_plate2)/1000;
    C2 = (block.h_flow2*block.A_flow2_plate2)/1000;
    C3 = (block.h_flow2*block.A_flow2_elec)/1000;
    C4 = (block.k_plate2*block.A_plate2_elecCond/block.L_plate2_heatCond)/1000;
    C5 = (block.k_plate1*block.A_plate1_elecCond/block.L_plate1_heatCond)/1000;
    C6 = (block.h_flow1*block.A_flow1_elec)/1000;
    C7 = (block.h_flow1*block.A_flow1_plate1)/1000;

    for k = 1:1:nodes
        %QT1 : heat transfer into oxidizer plate
        A(k,k) = -1;
        if s==5
            A(k,k+s*nodes) = -(C1+C2+C4);
            A(k,k+(s+4)*nodes) = C1;
        elseif s==6
            A(k,k+s*nodes) = -(C8+C2+C4);
            A(k,k+(s+5)*nodes) = (1-a)*C8;
        end
        A(k,k+(s+1)*nodes) = (1-a)*C2; %averaged with inlet temp or previous node temp
        A(k,k+(s+2)*nodes) = C4;

        %QT2 : heat transfer into Flow2
        A(k+nodes,k+nodes) = -1;
        A(k+nodes,k+(s+1)*nodes) = -(1-a)*(C2+C3);
        A(k+nodes,k+s*nodes) = C2;
        A(k+nodes,k+(s+2)*nodes) = C3;

        [i,j] = find(block.Flow2Dir==k);
        if j==1 %first column averaged with inlet temperature
            A(k,2*s*nodes+2) = a*C2;
            A(k+nodes,2*s*nodes+2) = -a*(C2+C3);
            A(k+2*nodes,2*s*nodes+2) = a*C3;
        else % other columns averaged with previous one
            k2 = block.Flow2Dir(i,j-1);
            A(k,k2+(s+1)*nodes) = a*C2;
            A(k+nodes,k2+(s+1)*nodes) = -a*(C2+C3);
            A(k+2*nodes,k2+(s+1)*nodes) = a*C3;
        end

        %QT3 : heat transfer into electrolyte
        A(k+2*nodes,k+2*nodes) = -1;
        A(k+2*nodes,k+(s+2)*nodes) = -(C3+C4+C5+C6);
        A(k+2*nodes,k+(s+1)*nodes) = (1-a)*C3; %averaged with inlet temp or previous node temp
        A(k+2*nodes,k+s*nodes) = C4;
        A(k+2*nodes,k+(s+4)*nodes) = C5;
        A(k+2*nodes,k+(s+3)*nodes) = (1-a)*C6;

        %QT4 : heat transfer into Flow1
        A(k+3*nodes,k+3*nodes) = -1;
        A(k+3*nodes,k+(s+3)*nodes) = -(1-a)*(C6+C7);
        A(k+3*nodes,k+(s+2)*nodes) = C6;
        A(k+3*nodes,k+(s+4)*nodes) = C7;

        [i,j] = find(block.Flow1Dir==k);
        if j==1 %first column averaged with inlet temperature
            if s==6 %pull last temperature from Flow3
                k2 = block.Flow3Dir(i,end);
                A(k+2*nodes,k2+(s+5)*nodes) = a*C6;
                A(k+3*nodes,k2+(s+5)*nodes) = -a*(C6+C7);
                A(k+4*nodes,k2+(s+5)*nodes) = a*C7;
            else
                A(k+2*nodes,2*s*nodes+1) = a*C6;
                A(k+3*nodes,2*s*nodes+1) = -a*(C6+C7);
                A(k+4*nodes,2*s*nodes+1) = a*C7;
            end
        else % other columns averaged with previous one
            k2 = block.Flow1Dir(i,j-1);
            A(k+2*nodes,k2+(s+3)*nodes) = a*C6;
            A(k+3*nodes,k2+(s+3)*nodes) = -a*(C6+C7);
            A(k+4*nodes,k2+(s+3)*nodes) = a*C7;
        end

        %QT5 : heat transfer into fuel plate
        A(k+4*nodes,k+4*nodes) = -1;
        if s==5
            A(k+4*nodes,k+(s+4)*nodes) = -(C1+C5+C7);
            A(k+4*nodes,k+s*nodes) = C1;
        elseif s==6
            A(k+4*nodes,k+(s+4)*nodes) = -(C8+C5+C7);
            A(k+4*nodes,k+(s+5)*nodes) = A(k+4*nodes,k+(s+5)*nodes) + (1-a)*C8;
        end
        A(k+4*nodes,k+(s+2)*nodes) = C5;
        A(k+4*nodes,k+(s+3)*nodes) = (1-a)*C7;

        if s==6 %QT6 : heat transfer into Flow3 gas
           A(k+5*nodes,k+5*nodes) = -1;
           A(k+5*nodes,k+(s+5)*nodes) = -C8; 
           A(k+5*nodes,k+s*nodes) = C8; 
           A(k+5*nodes,k+(s+4)*nodes) = C8; 

           [i,j] = find(block.Flow3Dir==k);
            if j==1 %first column averaged with inlet temperature
                A(k,2*s*nodes+1) = a*C8;
                A(k+4*nodes,2*s*nodes+1) = a*C8;
                A(k+5*nodes,2*s*nodes+1) = -C8;
            else % other columns averaged with previous one
                k2 = block.Flow3Dir(i,j-1);
                A(k,k2+(s+5)*nodes) = a*C8;
                A(k+4*nodes,k2+(s+5)*nodes) = a*C8;
                A(k+5*nodes,k2+(s+5)*nodes) = -C8;
            end
        end

        %Tox : Temeraure of oxidizer plate (net heat transfer into plate = 0)
        A(k+s*nodes,k) = 1;

        %Tcath: Temperature of Flow2
        A(k+(s+1)*nodes,k+nodes) = 1;
        A(k+(s+1)*nodes,k+(s+1)*nodes) = -q2;
        [i,j] = find(block.Flow2Dir==k);
        if j==1 %first column receives fresh air
            A(k+(s+1)*nodes,2*s*nodes+2) = q2;
        else
            index = block.Flow2Dir(i,j-1);
            A(k+(s+1)*nodes,index +(s+1)*nodes) = q2;
        end

        %Telec: Temperature of electrolyte
        A(k+(s+2)*nodes,k+2*nodes) = 1;

        %Tan: Temperature of Flow1
        A(k+(s+3)*nodes,k+3*nodes) = 1;
        A(k+(s+3)*nodes,k+(s+3)*nodes) = -q1; 
        [i,j] = find(block.Flow1Dir==k);
        if j==1 %first column receives fresh fuel
            if s==5
                A(k+(s+3)*nodes,2*s*nodes+1) = q1; %fresh inlet
            elseif s==6
                index = block.Flow3Dir(i,end);
                A(k+(s+3)*nodes,index+(s+5)*nodes) = q1; %Flow3 out
            end
        else
            index = block.Flow1Dir(i,j-1);
            A(k+(s+3)*nodes,index+(s+3)*nodes) = q1;
        end

        %Tfuel: Temperature of fuel plate (net heat transfer into plate = 0)
        A(k+(s+4)*nodes,k+4*nodes) = 1;

        if s==6 %Treform : Temperature of Flow3 gas
           A(k+(s+5)*nodes,k+5*nodes) = 1;
           A(k+(s+5)*nodes,k+(s+5)*nodes) = -q3;
           [i,j] = find(block.Flow3Dir==k);
            if j==1 %first column receives fresh fuel
                A(k+(s+5)*nodes,2*s*nodes+1) = q3;%fresh inlet
            else
                index = block.Flow3Dir(i,j-1);
                A(k+(s+5)*nodes,index+(s+5)*nodes) = q3;
            end 
        end
    end

    %remove temperature averaging at Flow2 inlet node
    k1 = block.Flow2Dir(:,1); %first column
    for n =1:1:length(k1)
        k = k1(n);
        A(k,k+(s+1)*nodes) = A(k,k+(s+1)*nodes) + a*C2; %HT to ox plate from Flow2
        A(k,2*s*nodes+2) = A(k,2*s*nodes+2) - a*C2; %HT to ox plate from Flow2

        A(k+nodes,k+(s+1)*nodes) = A(k+nodes,k+(s+1)*nodes) - a*(C2+C3); %HT from ox plate and electrolyte to Flow2
        A(k+nodes,2*s*nodes+2) = A(k+nodes,2*s*nodes+2) + a*(C2+C3);   %HT from ox plate and electrolyte to Flow2

        A(k+2*nodes,k+(s+1)*nodes) = A(k+2*nodes,k+(s+1)*nodes) + a*C3;%HT from the Flow2 to electrolyte
        A(k+2*nodes,2*s*nodes+2) = A(k+2*nodes,2*s*nodes+2) - a*C3; %HT from the Flow2 to electrolyte
    end

    if s==6 %remove temperature averaging at Flow1 inlet node
        k1 = block.Flow3Dir(:,1); %first column
        for n =1:1:length(k1)
            k = k1(n);
            A(k+5*nodes,k+(s+5)*nodes) = A(k+5*nodes,k+(s+5)*nodes) - C8; %HT to reform gas from fuel and ox plates
            A(k+5*nodes,2*s*nodes+1) = A(k+5*nodes,2*s*nodes+1) + C8; %HT to reform gas from fuel and ox plates

            A(k,k+(s+5)*nodes) = A(k,k+(s+5)*nodes) + a*C8; %HT from Flow3 to ox plate
            A(k,2*s*nodes+1) = A(k,2*s*nodes+1) - a*C8;   %HT from Flow3 to ox plate

            A(k+4*nodes,k+(s+5)*nodes) = A(k+4*nodes,k+(s+5)*nodes) + a*C8;%HT into the fuel plate from Flow3
            A(k+4*nodes,2*s*nodes+1) = A(k+4*nodes,2*s*nodes+1) - a*C8; %HT into the fuel plate from Flow3
        end

    else
        k1 = block.Flow1Dir(:,1); %first column
        for n =1:1:length(k1)
            k = k1(n);
            A(k+3*nodes,k+(s+3)*nodes) = A(k+3*nodes,k+(s+3)*nodes) -a*(C6+C7); %HT to Flow1 from fuel plate & electrolyte
            A(k+3*nodes,2*s*nodes+1) = A(k+3*nodes,2*s*nodes+1) + a*(C6+C7);   %HT to Flow1 from fuel plate & electrolyte

            A(k+4*nodes,k+(s+3)*nodes) = A(k+4*nodes,k+(s+3)*nodes) + a*C7; %HT from Flow1 to fuel plate
            A(k+4*nodes,2*s*nodes+1) = A(k+4*nodes,2*s*nodes+1) - a*C7;   %HT from Flow1 to fuel plate

            A(k+2*nodes,k+(s+3)*nodes) = A(k+2*nodes,k+(s+3)*nodes) + a*C6; %HT into the electrolyte from Flow1
            A(k+2*nodes,2*s*nodes+1) = A(k+2*nodes,2*s*nodes+1) - a*C6;%HT into the electrolyte from Flow1
        end
    end
end
HTconv = A(1:s*nodes,s*nodes+1:2*s*nodes);%matrix of coefficients to multiply by vector of temperature and get the heat transfer by conduction & convection between layers and nodes

%% Conduction: left and right, prev and next
A2 = zeros(states+c,states);
prev = block.HTadjacent(:,1);
next = block.HTadjacent(:,2);
left = block.HTadjacent(:,3);
right = block.HTadjacent(:,4);

%conduction coefficients
if s<=3
    for k = 1:1:nodes
        A2(k+nodes,k+(s+1)*nodes) = A2(k+nodes,k+(s+1)*nodes) -2*block.ConductionPN -2*block.ConductionLR;
        A2(k+nodes,prev(k)+(s+1)*nodes) = A2(k+nodes,prev(k)+(s+1)*nodes)+block.ConductionPN;
        A2(k+nodes,next(k)+(s+1)*nodes) = A2(k+nodes,next(k)+(s+1)*nodes)+block.ConductionPN;
        A2(k+nodes,left(k)+(s+1)*nodes) = A2(k+nodes,left(k)+(s+1)*nodes)+block.ConductionLR;
        A2(k+nodes,right(k)+(s+1)*nodes) = A2(k+nodes,right(k)+(s+1)*nodes)+block.ConductionLR; 
    end
else

    H1_pn = (block.k_plate2*block.A_plate2_heatCond/(block.L_node/2))/1000; %heat transfer coefficient between previous and next node of oxidant plate
    H1_lr  = (block.k_plate2*block.A_plate2_heatCond/(block.W_node/2))/1000; %heat transfer coefficient between left and right adjacent nodes of oxidant plate
    H2_pn  = (block.k_Elec*block.A_Elec_Heat_Cond/(block.L_node/2))/1000; %heat transfer coefficient between previous and next node of fuel cell electrolyte assembly
    H2_lr  = (block.k_Elec*block.A_Elec_Heat_Cond/(block.W_node/2))/1000; %heat transfer coefficient between left and right adjacent nodes  of fuel cell electrolyte assembly
    H3_pn  = (block.k_plate1*block.A_plate1_heatCond/(block.L_node/2))/1000; %heat transfer coefficient between previous and next node of fuel plate
    H3_lr  = (block.k_plate1*block.A_plate1_heatCond/(block.W_node/2))/1000; %heat transfer coefficient between left and right adjacent nodes of fuel plate

    for k = 1:1:nodes
        if prev(k) ~=k
            A2(k,k+s*nodes) = A2(k,k+s*nodes)-H1_pn;
            A2(k,prev(k)+s*nodes) = A2(k,prev(k)+s*nodes)+H1_pn;
            A2(k+2*nodes,k+(s+2)*nodes) = A2(k+2*nodes,k+(s+2)*nodes)-H2_pn;
            A2(k+2*nodes,prev(k)+(s+2)*nodes) = A2(k+2*nodes,prev(k)+(s+2)*nodes)+H2_pn;
            A2(k+4*nodes,k+(s+4)*nodes) = A2(k+4*nodes,k+(s+4)*nodes)-H3_pn;
            A2(k+4*nodes,prev(k)+(s+4)*nodes) = A2(k+4*nodes,prev(k)+(s+4)*nodes)+H3_pn;
        end
        if next(k) ~=k
            A2(k,k+s*nodes) = A2(k,k+s*nodes)-H1_pn;
            A2(k,next(k)+s*nodes) = A2(k,next(k)+s*nodes)+H1_pn;
            A2(k+2*nodes,k+(s+2)*nodes) = A2(k+2*nodes,k+(s+2)*nodes)-H2_pn;
            A2(k+2*nodes,next(k)+(s+2)*nodes) = A2(k+2*nodes,next(k)+(s+2)*nodes)+H2_pn;
            A2(k+4*nodes,k+(s+4)*nodes) = A2(k+4*nodes,k+(s+4)*nodes)-H3_pn;
            A2(k+4*nodes,next(k)+(s+4)*nodes) = A2(k+4*nodes,next(k)+(s+4)*nodes)+H3_pn;
        end
        if left(k) ~=k
            A2(k,k+s*nodes) = A2(k,k+s*nodes)-H1_lr;
            A2(k,left(k)+s*nodes) = A2(k,left(k)+s*nodes)+H1_lr;
            A2(k+2*nodes,k+(s+2)*nodes) = A2(k+2*nodes,k+(s+2)*nodes)-H2_lr;
            A2(k+2*nodes,left(k)+(s+2)*nodes) = A2(k+2*nodes,left(k)+(s+2)*nodes)+H2_lr;
            A2(k+4*nodes,k+(s+4)*nodes) = A2(k+4*nodes,k+(s+4)*nodes)-H3_lr;
            A2(k+4*nodes,left(k)+(s+4)*nodes) = A2(k+4*nodes,left(k)+(s+4)*nodes)+H3_lr;
        end
        if right(k) ~=k
            A2(k,k+s*nodes) = A2(k,k+s*nodes)-H1_lr;
            A2(k,right(k)+s*nodes) = A2(k,right(k)+s*nodes)+H1_lr;
            A2(k+2*nodes,k+(s+2)*nodes) = A2(k+2*nodes,k+(s+2)*nodes)-H2_lr;
            A2(k+2*nodes,right(k)+(s+2)*nodes) = A2(k+2*nodes,right(k)+(s+2)*nodes)+H2_lr;
            A2(k+4*nodes,k+(s+4)*nodes) = A2(k+4*nodes,k+(s+4)*nodes)-H3_lr;
            A2(k+4*nodes,right(k)+(s+4)*nodes) = A2(k+4*nodes,right(k)+(s+4)*nodes)+H3_lr;
        end   
    end
end
HTcond = A2(1:s*nodes,s*nodes+1:2*s*nodes);%matrix of coefficients to multiply by vector of temperature and get the heat transfer by conduction & convection between layers and nodes
A = A + A2;

%% Radiative Heat transfer
HTrad = zeros(s*nodes,s*nodes);


% Qscale = b(2*s*nodes+3)/max(abs(b(s*nodes+1:2*s*nodes)))/10;%scaling so more emphasis is put on balancing temperature than on balancing Q
% b(s*nodes+1:2*s*nodes) = Qscale*b(s*nodes+1:2*s*nodes);
% A(1:s*nodes,s*nodes+1:2*s*nodes+2) = Qscale*A(1:s*nodes,s*nodes+1:2*s*nodes+2);

%% Constraints
%Flow1 Inlet Temperature
A(2*s*nodes+1,2*s*nodes+1) = 1;
b(2*s*nodes+1) = Inlet.Flow1.T;
if inT>1 %Flow2 Inlet Temperature
    A(2*s*nodes+2,2*s*nodes+2) = 1; 
    b(2*s*nodes+2) = Inlet.Flow2.T;
end

if c > 0 %Average electrolyte temp  constraint 
    for j = 1:1:nodes %Average all the electrolyte temps to equal Tpenavg
        A(2*s*nodes+3,j+(s+2)*nodes) = 1/nodes;
    end 
    b(2*s*nodes+3) = block.TpenAvg;
    %Flow2 dT constraint: T3 - T2 = T2 - T1
    col = length(block.Flow2Dir(1,:));% # of columns
    rows = length(block.Flow2Dir(:,1)); % # of rows
    for i =1:1:col-1
        if i ==1
            A(2*s*nodes+3+i,2*s*nodes+2) = 1; %Flow2 inlet (T1)
        else A(2*s*nodes+3+i,block.Flow2Dir(:,i-1)+(s+1)*nodes) = 1/rows;%first column (T1)
        end
        A(2*s*nodes+3+i,block.Flow2Dir(:,i)+(s+1)*nodes) = -2/rows; %middle column (T2)
        A(2*s*nodes+3+i,block.Flow2Dir(:,i+1)+(s+1)*nodes) = 1/rows; %last column (T3)
        b(2*s*nodes+3+i) = 0;
    end
end
x= A\b;
T = x(s*nodes+1:2*s*nodes);


% %% Radiative heat transfer %%
% Ar = 0*A;
% for j = 1:s*nodes
%     Ar(1:s*nodes,s*nodes+j) = HTrad(1:s*nodes,j).*T(i).^3;
% end
% A = A + Ar;
% 
% error = true;
% a = 1; %convergence gain factor
% count = 0;
% while error % converges to correct temperatures with radiative heat transfer
%     Told = T;
%     x = A\b;
%     T = a*x(s*nodes+1:2*s*nodes) + (1-a)*Told;
%     if max(abs(T-Told))<.1
%         error = false;
%     end
%     count = count+1;
%     if count>10
%         disp('Slow convergence in radiative heat transfer')
%     end
% end
% %     QT = x(1:s*nodes);